方法
1.作用： 
		方法是一段可以完成某个特定的功能，可以重复利用的代码片段
		定义在类体中，自上而下的逐行执行，不定义在主方法中，主方法负责调用相关的方法。
		在后面的开发中，某个功能可以独立抽取出来，可以考虑直接定义一个方法，后面直接调用这个方法即可。
		方法中定义的变量称之为：局部变量。
		main方法不需要程序员手动调用，是JVM调用的，但是main方法之外的其他方法，都需要程序员手动调用，
		方法只有在调用之后才会执行。
2.方法怎么定义，语法机制是什么

		没有方法的话，会存在什么问题：代码的复用性差，功能相同不需要重复编写。

			方法定义的类体中，顺序不重要，主方法不调用，他不执行。

			方法的语法机制：
					[修饰符列表]		返回值类型	方法名（形式参数列表）{
							方法体；
					}

				注意：[ ]里面的内容表示不是必须的，是可选的，由java语句构成。

			关于修饰符列表：不是必选项，是可选的，目前统一写成public static。

			关于返回值类型：

					1.可以是任意的类型，包括基本的数据类型+引用数据类型，也就是说，返回值可以是：byte，short，int，
						long，float，double，Boolean，char，String。。

					2.方法结束之后，大部分情况下都是有一个结果的，一般都是以数据的形式体现出来，
						方法执行结束之后，返回值返回给调用方。

					3.当一个方法执行结束之后，不返回任何返回值的时候，返回值类型也不能是空白，必须写上void关键字，
						所以void表示该方法执行之后不返回任何结果。

					4.如果返回值类型不是void，那么方法体结束时，必须使用“return  值”这样的语句来完成值的返回，如果
						没有return值，编译报错。

					5.只要有return关键字的语句执行，当前方法必结束。注意不是整个程序结束，是当前的方法结束。

					6.如果返回值类型是void，那么在方法体当中，不能有“return 值”这样的语句，但是可以有“return”语句，
						return的作用就是：终止当前的方法。

					7.除了void之外，剩下的都必须有“return 值”这样的语句。

			方法名：
					方法名要见名知意；
					 驼峰式命名规则，首字母小写，后面每个单词的首字母大写

			形式参数列表：
					形式参数的每一个变量都是局部变量，方法结束之后，内存释放，
					形参的个数是0-n个，
					形参的数据类型及决定性作用，其对应的变量名是随意的。
					形参之间用英文的逗号隔开；

			方法体：
					方法体的编写是业务逻辑代码，完成某个特定的功能，遵循自上而下的执行顺序，
					在方法体中处理业务的逻辑代码的时候需要数据，数据的来源就是这些形参。
					方法体只有调用之后才能执行，执行的语法是：
							类名.方法名（实际参数列表）；


栈的数据结构：

		JVM（java虚拟机）主要的的的三块内存空间：
					栈、堆、方法区 以及其他的

					方法区：类加载器classloader将硬盘上的xxx.class字节码文件装载到JVM的时候，会将
					字节码文件存放到方法区当中。即方法区中存储的是代码片段。因为类需要加载，所以
					方法区中最先有数据。

					栈（stack）内存：在方法被调用的时候，该方法需要的内存空间需要在栈中分配。

					堆区：堆内存，后面讲。

		一种经典的数据结构：栈数据结构：stack

		数据结构：

					存储数据的容器；
					该容器中可能存在不同的结构
					和数据结构通常一起出现的是算法；

		栈数据结构：先进后出，后进先出
						
						数据存入栈存储器的过程称为：进栈，入栈，压栈，push
						数据从栈存储器的过程称之为：出栈，弹栈，pop
			
						栈帧永远指向的是栈顶部的元素，处于栈顶部的元素具有活跃权 

						最先进来的元素会在栈的底端，即栈底元素；后进来的数据处于栈的顶端，即栈顶元素


	

	方法重载的机制：

		优点1：代码整齐美观
		优点2：功能相似的代码，可以让方法名重名，方便以后的编写

		在java语言中：
				进行使用的方法区分时，首先java编译器通过方法名进行区分，
				但是在java语言中允许方法名相同的情况出现
				如果方法名重名了，编译器通过方法的参数类型进行方法的区分；


什么时候要考虑方法重载：方法名相同，形参不同

		如果在同一个类中，如果功能1和功能2功能相似，那么可以考虑将他们的方法名一致。这样代码美观
		同时便于代码编写。

		注意：方法重载不能随便使用，如果两个功能根本不同，就不便于使用方法重载。
					方法重载和返回值类型无关，与函数名和参数类型有关。

		条件：满足以下的条件，就可以认为方法与方法之间发生了方法重载机制。
				
					同一个类当中

					方法名相同

					参数列表不同：

							参数的个数不同

							参数的类型不同

							参数的顺序不同


							以下这种情况就不属于方法重载，因为参数的类型决定了两个方法的一致，
							如果调用时给出   m1(1,100)那么就会出现编译器识别不了到底采用哪个m1来进行调用。
							以下属于方法调用。

							public static void m1(int a ,int b){}

							public static void m1(int x ,int y){}


							以下的方法也不属于方法重载，属于方法重复：
							方法重载和返回值类型无关，如果调用时，直接调用  m1()   那么返回int 还是返回double就不确定了

							public static int m1(){}

							public static double m1(){}


							以下的方法也不是方法重载，属于方法重复：与修饰符列表的有无无关。
									
									void m1(){}

									public static void m1(){}



					实际上：System.out.println()代码中可以看到，println（）就是一个方法的重载，方法名就是println，
									参数类型不同而已


	封装：目前仅仅实现同一个文件夹下面的封装调用：

			在编译时，如果没有事先编译FengZhuang01这个文件的话，编译器会自动编译生成FengZhuang01.class 文件
		只要有了.class文件，即可进行调用，但是，目前仅仅在同一文件里面进行调用，并且只要有了.class文件就可以
		不需要.java 文件



方法递归：
		
		方法自己调用自己就是方法递归

		public static void m1(){
					m1();-----------------------------自己调用自己
		}


		栈的内存是有限的，所以如果一直压栈，不进行弹栈的话，就会出现栈内存溢出的错误StackOverFlowError

		当递归时 程序没有结束条件，一定会发生栈内存溢出错误，所以递归必须有结束条件。

		递归有结束条件也可能会出现栈的内存溢出的错误，原因是递归的太深，栈内存不够了，因为一直在压栈

		在实际开发中，不要轻易选择递归，能用for循环或者while循环代替最好，因为循环的效率高，耗费的内存小，
		递归损耗的内存比较大，另外，递归如果使用不当的话会使JVM死掉，但是极少数的条件下，你不用递归有些
		程序是无法实现的


	实际开发中，如果出现栈溢出的错误要怎么解决：
			首先：先检查递归的结束条件是否正确；进行改进
			第二：如果结束条件没问题的话，需要手动调整JVM的栈内存初始化大小，将栈内存的空间调大一点
			第三：调整了大小任然报错，只能继续扩大栈的内存大小。
			（java -x）这个可以查看调整堆栈大小的参数

			