数据类型

1.用处：不同数据类型划分的储存空间大小
2.分类：
		基本数据类型：
				基本数据类型可以分为四大类八小类

				四大类：整数型（byte short int long ） 浮点型(float double ) 布尔型(boolean) 字符型(char)

             对应字节数（byte）1    2      4     8                        4         8                          1                      2

				八小类：byte short int long float double boolean char

		 引用数据类型：
				字符串型String属于引用数据类型，不属于基本数据类型范畴
				java中除了基本数据类型之外，剩下的都是引用数据类型
				引用数据类型后期面向对象才会接触
3.八种基本类型中的区别：
		一个字节byte=8个bit---->1byte=8bit
		1short=2byte=16bit
		1int=4byte=32bit
		1long=8byte=64bit
		1float=32bit
		1double=64bit
		1boolean=8bit
		1char=16bit

		eg:  byte t=2;
					在计算机中表示为：00000010
				short a=2;
					在计算机中表示为：00000000  00000010
				int d=2;
					在计算机中表示为：00000000  00000000  00000000  00000010

		在计算机中：
				1KB=1024byte
				1MB=1024KB
				1GB=1024MB
				1TB=1024GB
		

4.byte类型的取值范围 

		byte 是一个字节，8个比特位，所以byte最大的存储值是：
					
					01111111   
				
				其中一个二进制位最左边是符号位，0时表示正数，1时表示负数，
				因此，byte取值范围是[-128~127]

				byte 范围[-128~127]
				short范围[-32768~32767]可以表示65536个不同的数字
				int 范围[-2147483648~2147483647]
				char 范围[0~65535]

				short和char实际上容量相同，不过是char可以表示更大的数字。
				由于char是字符没有正负之分，所以char可以表示更大的数字。

5.布尔类型也用数字表示
		实际上boolean仅有两个值，true和false；其中true用1表示，false用0表示。
		即true :00000001     false:00000000(布尔类型占一个字节)

		对于char 来说，比较麻烦，表示文字，每个国家文字不同，文字不能直接通过自然算法进行转换
		字符编码诞生了

		字符编码是人为规定的一套转换表。
		在字符编码中规定了一系列的文字对应的二进制。
		实际上就是一本字典，描述文字与二进制之间的对照关系。
		字符编码是人为规定的，是国内某个计算机协会规定的。

		字符编码涉及到编码和解码两个过程，编码和解码必须采用同一套编码方式，否则会乱码。

		ASCII码：采用1byte进行存储，因为键盘上所有键加起来也不超过256个，1个byte可以表示256种
		不同的编码方式。
		a----------->97--------->01100001(采用ASCII码进行编码)
		01100001------------>a（采用ASCII进行解码）
		A---------->65
		0----------->48(此处的0实际上是文字0)

		随着计算机语言的发展，国际标准组织制定了ISO-8859-1编码方式（又称之为latin-1编码方式），
		不支持中文，向上兼容ASCII码

		后来发展到亚洲，才支持中文日文韩文
		中文采用的是:GB2312<GBK<GB18030(容量的关系)-----简体中文
		繁体中文----------big5

		在java中，java语言为了支持全球所有的文字，采用一种字符串编码的方式，叫做Unicode编码
		Unicode统一了全球所有文字，包括：UTF-8<UTF-16<UTF-32...

6. 8种数据类型详解

		关于java中的转义字符 

					java 语言中'\'负责转义

					\t表示制表符tab

					\n表示换行,实际在写程序过程中，需要加双引号

					System.out.print();
					System.out.println();-----------加了ln表示换行输出，否则不换行

					\u表示后面的是一个字符的Unicode编码，输出即可显示该实际字符

7.整数型在java中的4种类型：

			public class IntTest.01{
					public static void main(String[] args){
							//十进制
							int a=10;------------------十进制正常数字
							System.out.println(a);
							//八进制
							int b=010;----------------八进制以0开头
							System.out.println(b);
							//16进制
							int c=0x10;---------------16进制以0x开头
							System.out.println(c);
							//二进制
							int d=0b10;---------------2进制以0b开头
							System.out.println(d);
					}
			}

			在java中，在任何情况下，数据型的字面量/数据 默认被当做int处理；如果希望
			整数型字面量被当做long类型处理，需要在字面量后面添加L/l

			long s=200；-----------自动类型转换：小容量可以直接赋值给大容量
			long a=300L ；---------不存在数据类型转换
			long b=2147483647；------该数据为int类型的最大值，存在数据类型转换
			long c=2147483648；------大于int的最大范围，将会报错；在数据后面加L就不会报错


			long a=100L；
			int b=a；-------------------将会报错；大容量转换为小容量；
																	会输出：不兼容的类型，可能会出现精度损失
 
			想要编译通过，必须加强制类型转换符，但是运行时可能出现精度损失
			int b=（int）a-----------这里（int）就是强制类型转换符

		底层进行强制转换的方法：
		100 的二进制为：
		00000000 00000000 00000000 00000000 00000000 00000000 00000000 01100100
		在进行强制类型转换的时候，会自动将前面的4个字节“砍掉”，
		此处数据很小，砍掉不会出现精度损失

		byte b=300；-------------300被默认为int类型，出现大容量转换为小容量
															强制类型转化出现精度损失。
		300:  00000000 00000000 00000010 00101100
		转换为一个字节的时候，将会出现精度损失

		byte x=1；-----------语法规则：当右侧数据没有超出byte的最大范围的时候，这个整数型数据可以直接
															赋值给byte类型的变量，方便编程。
		short g=32767；---------同样的规则，没有超过数据类型short的最大的范围的时候，编译可以通过

		没有超出char的取值范围是否可以直接运行嘛？

				char y=97;----------------------可以直接运行，输出ASCII码对应的字符a
				System.out.println(y);

				//char v=65536;----------------------不可以直接运行，超出 char的最大范围
				//Systenm.out.println(v);

				//CharTest01.java:58: 错误: 不兼容的类型: 从int转换到char可能会有损失
                            //    char v=65536;


			char a1=65535;------------可以直接运行
			System.out.println(a1);

			结论：当一个整数没有超出byte,short,char的取值范围的时候，
							可以直接赋值给byte short char类型的变量(注意：int无法转换为boolean)

8.在byte char short 做混合运算的时候，各自先转换为int 再进行运算
		
				char c1='a';
				byte d=1;
				System.out.println(c1);//-----------输出结果为字符 a
				System.out.println(c1+d);//----------此处可以进行输出
				
							short s=c1+d;---------//报错原因：右边转化为int类型进行相加之后，
																		//虽然数据值为98没有超过short的最大范围，
																		//但是编译器并不能直接认为此处的输出数据
																		//与short类型的范围的大小关系;只知道是int类型的，所以报错

							//IntTest02.java:12: 错误: 不兼容的类型: 从int转换到short可能会有损失
													//  short s=c1+d;

							//如果想输出结果，需先对等号右边进行强制转化：

			short s=(short)(c1+d);
			System.out.println(s);

9.报错理由----------------编译器只识别数字类型（在等号右边不是直接显示数字的情况下）
				int a=1;
				short s=a;
				System.out.println(s);

10.多种类型混合运算的时候，最终结果类型是“最大容量”对应的类型
		
		但是char+short+byte除外；这个过程会先自行转换成int类型再做运算

		java 中规定，int类型最终结果还是int类型

11.关于java中浮点型数据：float（4个字节）  double（8个字节）

				float为单精度；double为双精度：double更精确

				但是需要注意的是：如果在银行方面或者在财务方面，double也是远远不够的。

				在java中提供了一种精度更高的类型，这种类型专门在财务软件方面：Java.math.BigDecimal
																																		(不是基本数据类型，属于引用数据类型)

				float 和double存储数据的时候都是存储近似值；
				因为现实世界中数据实际上是无线循环的，只能近似存储

			
				long 类型占用八个字节，float类型占用4个字节---------------那个容量更大？
						
						注意：任意一个浮点型都比整数型空间大

										float容量>long容量


				浮点型数据默认为double类型来处理；如果想让浮点型数据被当做float类型来处理的话，需要在后面添加F/f
						
						1.0被默认为double类型处理
						
						1.0F这才是float类型

12.Boolean类型

				在java中boolean仅仅包括true false

				不像C或者C++中1和0也可以表示真假

				实际开发中，通常放在条件的位置上（充当条件）

13.综合来看：
		
		1.八种基本类型中，除了Boolean类型不能进行转换，剩余7种类型都可以转换

		2.没有超出byte short char的范围，整数型字面量可以直接将其赋值给byte short char类型变量

		3.小容量向大容量可以进行自动类型转换。容量从小到大进行排序为：

				byte<short(char)<int<long<float<double,其中short和char都占用两个字节，
				但是char可以表示更大的正整数

		4.大容量转化成小容量，为强制类型转化，编写时必须加强制类型转换符；但是运行时可能会
				出现精度损失

		5.byte short char类型混合运算时，先各自转换成int类型再做运算

		6.多种数据类型混合运算，先各自转化成容量最大的那一种再做运算

14.运算符：
		算数运算符
						% 求余数（求模）
										int a=10%3;
										System.out.println(a);---------------输出1，表示取余数

						++自加1
						--自减1

						对于++运算符来说，可以出现在变量前，也可以出现在变量后，
						总之++命令执行之后，变量值一定加一

						++在变量之前，则变量先加一再赋值
						++在变量之后，先赋值再变量自身加一

		关系运算符

				 >		>=			<		 <=		==		!=
				 一定要记住：所有的运算符运算结果都是布尔类型，不是true就是false；不可能等于其他值
				 其中：=表示赋值  ==表示关系运算，判断是否相等
				 注意：关系运算符中间不能有空格

		逻辑运算符

			逻辑运算符两边要求都是布尔类型，并且最终的运算结果也是布尔类型

				100&true ---->错误，没有这样的语法

					&逻辑与（并且）
					|逻辑或（或者）
					！逻辑非
					&&短路与
					||短路或

					&&短路与：运算结果与&没有任何区别；只不过&&会出现短路现象
							短路现象：int a=10;
														int b=11;
														System.out.println(a>b&a>b++);
							//&与表示：当两边都为真时，才会为真，
							//所以在左边已经是假的情况下，左边不必要执行，也可以输出假的结果
					System.out.println(b);
							//但是实际上，运行结果仍然是12，即右边还是运行了

					int x=10;
					int y=11;
					System.out.println(x>y&&x>y++);
							//在&&运行的状态下，右边输出依旧是11，
							//也就是在左边为假的状态下，右边已经不再运行，即短路现象
					System.out.println(y);

		赋值运算符

				包括基本赋值运算符   =----------------执行时，右边优先级比较高，先执行右边的表达式
																									然后将执行结束的结果放在左边的“盒子”当中
						
							扩展赋值运算符	+=---------------扩展运算符在编写的时候，两运算符之间不能有空格
																	-=
																	*=
																	/=
																	%=

					x+=1;
					System.out.println(x);//--------------重要机制：使用扩展赋值运算符时，
																			//永远不会改变运算结果类型。
																			//x自诞生就是byte类型，那么最后结果x仍然是byte类型

		位运算符


		条件运算符(三目运算符)：
		
						语法格式：
									布尔表达式？表达式1：表达式2

							执行原理：布尔表达式为true时，执行表达式1；
														结果为false时，执行表达式2作为整个表达式的结果


		字符串连接运算符

					1.+运算符在java中有两个作用：求和  或者  字符串拼接

					2.当+两边为数字类型的时候，求和
					  当+两边的任意一边为字符串类型的时候，字符串拼接

					3.字符串拼接之后还是一个字符串类型

					 

		其他运算符



其他问题：

			1.char类型可以存储一个中文的汉字吗：

						java中的文字采用unicode编码，一个中文占用2个字节，char类型在java中就是占用两
						个字节，所以java中的char类型完全可以容纳一个汉字。

			2.int i = 0xffff有问题吗？ 
			
						没有问题：0xffff以0x开始表示十六进制表示方式，ffff转换成十进制是：65535  
						
						
			3.char c = 65536有问题吗，为什么？ 
			
						65536已经超出char类型取值范围，不能直接赋值，这样修改：char c = (char)65536; 

			4.	特殊案例
					int i=10;
					i=i++;
					System.out.println(i);----------------输出结果是10；而在C++中输出结果是11

					过程：int i =10;
									int temp=i；先赋值
									i++; 再加一
									i=temp; 再赋值    而在C++中没有这一步；编译器的问题，原理不同
									System.out.println(i);