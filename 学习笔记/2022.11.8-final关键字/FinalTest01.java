/*final关键字：
		1.final是java语言中的一个关键字

		2.final表示最终的，不可变的

		3.final可以修饰变量以及方法，还有类等。

		*4.final修饰的变量？

			final修饰的局部变量，一旦被赋值，不能重新赋值。
			
			final修饰的变量只能赋一次值。


		*5.final修饰的方法？

			final修饰的方法无法被覆盖，被重写

		*6.final修饰的类？

				final修饰的类无法继承

		7.final控制不了能不能调用的问题。final管的是啥？

				final修饰的表示最后的，不能变的，不能改的。

		8.注意：局部变量没有初始值；成员变量才有初始值。


		final修饰的成员变量的值可以在同一类的不同对象中改变，而static final修饰的成员变量在同一类不同对象中不能改变。


		*/
final class A{//无法从最终A进行继承
//A没有子孙：绝育
//B类继承A类，相当于给A类的功能进行扩展，如果你不希望别人对你的
//A类型进行扩展；你可以给A类添加final关键字，这样A类就无法继承了。
}

class B extends A{

}


/*
class MyString extends String{
//java: 无法从最终java.lang.String进行继承
//比如对String的继承就无法进行，有final进行修饰了
}*/

class C
{
    public final void ABC(){
        System.out.println("C中的方法");
		//java: D中的ABC()无法覆盖C中的ABC()   被覆盖的方法为final
    }
}

class D extends C{
    public void ABC(){
        System.out.println("D中的方法");
    }
}




/*
final修饰的变量，如果这个变量是一个引用，会怎么样

    重点：final修饰的变量只能赋值一次

    显然：引用也是变量

final修饰的引用：

    该引用只能指向1个对象，并且只能永远指向该对象，无法再指向其他对象。

    在该方法执行过程中，该引用指向对象之后，该对象不会被垃圾回收器回收。
	直到当前的方法结束，才会释放空间

    虽然final的引用指向对象A后，不能再重新指向对象B，但是对象A内部的数据，是可以被修改的。
* */

/*
* final修饰的实例变量：
*   注意；万变不离其宗；final修饰的变量只能赋值一次
*
* 实例变量如果没有手动赋值的情况下，系统会自动赋值
*
* java程序设计，不背锅！甩锅甩的很好
*
* 实例变量在什么时候赋值（初始化）？
*   构造方法执行过程中赋值。（new的时候赋值）
*
* 终极结论：
*   final修饰的实例变量，系统不负责赋默认值，要求程序员必须手动赋值。
*   这个手动赋值，在变量后面赋值可以，在构造方法中赋值也可以。
*   无有参数构造方法的话，必须在无参数构造方法中赋值；
*   存在有参数构造方法时，如果也写了无参数构造方法，就必须要在无参数构造方法中对
*   final中赋值。
* */

/*
FinalTest03的结论：
    final修饰的实例变量，必须手动赋值
    《重点》final修饰的变量，只能赋值一次；

final修饰的实例变量一般添加static修饰；

终极结论：
    static final联合修饰的变量称为“常量”
    常量名建议全部大写，每个单词之间常用下划线衔接

常量:实际上常量和静态变量一样，区别在于：

    常量的值不能变，且在定义的时候就要赋好值，静态变量的值是可以改变的。

    常量和静态变量都是存储在方法区，并且都是在类加载时初始化。都是通过类名.的方式访问

    常量一般都是公共的：public的。

	常量只能在同一行定义：public static final int a=10；		不能分开两行写：public static final int a；		a=10;----------不被允许

	常量不能写在方法里面，只能写在方法外面；静态方法也不能写在方法里面（实测）

* */

/*

final关键字：

	final修饰的类无法继承；

	final修饰的方法无法覆盖；

	final修饰的变量只能赋一次值；

	final修饰的引用一旦指向某个对象，则不能再重新指向其他对象，但是该指向的对象内部的数据是可以修改的

	final修饰的实例变量必须手动初始化，不能采用系统默认值

	final修饰的实例变量一般和static联合使用，称为常量；

	  public static final double PI=3.1415926;

*/

332