抽象类+接口

抽象类概述：

	类到对象是实例化；对象到类叫抽象


抽象类：

        1.什么是抽象类？

            类和类之间具有的共同的特征，将这些共同特征提取出来，形成的就是抽象类。
            类本身是不存在的，所以抽象类无法创建对象《无法进行实例化》

        2.抽象类属于什么类型？

            抽象类属于引用数据类型。

       3.抽象类怎么定义？

            语法：

                [修饰符列表] abstract class 类名{
                    类体；
                }

       4.抽象类是无法进行实例化的，无法创建对象，所以抽象类是用来被子类继承的。------------------天生就是用来被继承的

       5.final 和 abstract 不能联合使用，这两个关键词是对立的。final修饰的类是无法被继承的

       6.抽象类的子类可以继续是抽象类，也可以不是

       7.抽象类无法进行实例化，但是抽象类有构造方法，这个构造方法是供子类使用的

       8.抽象类关联到一个新的概念：抽象方法；

            什么是抽象方法呢？      抽象方法： 表示没有实现的方法，没有方法体的方法。没有实现的方法。

            public abstract void doSome();

            抽象方法的特点是：
                1.没有方法体，以分号结尾
                2.前面修饰符列表中有abstract关键字；

       9.抽象类中不一定有抽象方法，但是抽象方法必须出现在抽象类中。


 抽象类：
*
*       1.抽象类中不一定有抽象方法，抽象方法必须出现在抽象类中。
*
*       2.重要结论：一个非抽象的类继承一个抽象的类的时候，必须将抽象类中的抽象方法实现了。

	     这是java语法强制规定的，必须的，不然编译器就报错了。
*
*           这里的覆盖或者说重写，也可以叫做实现（对抽象的实现）



写代码的时候： 能用多态就用多态！！！！！


到目前为止，只学了抽象类的基础语法，一个类到底声明为抽象还是非抽象，以后再说。

面试题（判断）：java语言中凡是没有方法体的方法都是抽象方法。
	
	错误的；Object中就有很多的方法没有方法体，都是以“;”结尾的，但是他们都不是抽象方法。例如：
		
		public native int hashCode();

		这个方法就没有方法体，但是这个方法调用了C++写的动态链接库的程序。
		前面的修饰符列表中没有abstract，有一个native，表示调用JVM本地程序；


接口：

    1.接口也是一种引用数据类型，编译之后也生成一个class字节码文件。

    2.接口是完全抽象的，（抽象类是半抽象）或者说接口是特殊的抽象类

    3.接口是怎么定义的，语法是什么？

		[修饰符列表] interface 接口名{}

    4.接口支持多继承，一个接口可以继承多个接口.

    5.接口中只允许出现两部分内容： 常量+抽象方法

    6.接口中的所有元素都是public修饰的，都是公开的；

    7.接口中的抽象方法定义时，public abstract修饰符可以省略；

    8.接口中的方法都是抽象方法，所以接口中的方法不能有方法体 ；

    9.接口中的常量的public static final 可以省略。---------接口中随便写一个变量就是常量，值 不能改变的就是常量

    10.一个非抽象的类，实现接口的时候，必须将接口中所有的方法加以实现；

    11.一个类可以实现多个接口；

    12.extends和implements同时出现的时候，extends在前，implements在后；

    13.使用接口，写代码的时候，可以使用多态，父类型的引用指向子类型的对象；


    抽象的(abstract)方法是否可同时是静态的(static)?

	不能,抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的

	静态的方法可以被继承，但是不能重写。如果父类中有1个静态的方法，子类也有1个完全一样的方法，
	
	那么该子类的方法会把父类的方法隐藏，而不是重写。
	
	通俗的讲就是父类的方法和子类的方法是两个没有关系的方法，
	
	具体调用哪个方法是看是哪个对象的引用；这种父子类方法也不存在多态的性质。




接口在开发中的作用：

	类似于多态在开发中的作用；

	多态：在开发中的作用，面向抽象编程，不要面向具体编程，降低程序的耦合度，提高程序的扩展能力；

	public class Master {
		public void feed(Dog d){}
		public void feed(Cat c){}
		假设又要喂养其他的动物的时候，有需要再加一个新的方法，要修改代码了；
		这样的扩展能力太差了，违背了OCP原则，开闭原则
	}
		
	public class Master{
		public void feed（Animal a）{}
		面向Animal父类编程，父类是比子类更加抽象的
		我们要面向父类编程，不要面向具体编程；
		这样的程序的扩展能力就强
		}



接口在开发中的作用？
	
	接口是不是完全的？ 是；

	而我们以后整好要求，面向抽象编程；

	面向抽象编程这句话可以修改为： 面向接口编程

	有了接口就有了可插拔，可插拔表示扩展能力强，不是焊死的；

	主板和内存条之间是有插槽的，这个插槽就是接口，内存条坏了，可以重新，买一个换下来，叫做高扩展性，低耦合度；

	接口在现实世界中到处都是：
		
		螺栓和螺母之间有接口，

		灯泡和灯口之间有接口，

		笔记本和键盘之间有接口，USB接口；USB接口是不是某个计算机协会制定的协议

		接口有什么用？扩展性好，可插拔；

		接口是一个抽象的概念；

	分析：

		中午去饭店吃饭，这个过程中有接口吗？
			
			接口是抽象的；

			菜单是一个接口。菜单上有一个抽象的照片，西红柿炒鸡蛋

			谁面向接口调用。顾客面向菜单点菜，调用接口；

			谁负责实现这个接口，后台的厨师负责把西红柿鸡蛋做好，是接口的实现者。

			这个接口有什么用？
				
				这个饭馆的菜单，让顾客和后厨解耦了，；

				顾客不用找后厨，后厨不用找顾客。他们之间完全依靠这个抽象的菜单沟通；



接口与抽象类的区别：这里我们只说在语法上的区别，后续在抽象类和接口上面去选择，通过项目练习去体会

		 1）接口不能有构造方法，抽象类可以有。

		 2）接口不能有方法体，抽象类可以有。

		 3）接口不能有静态方法，抽象类可以有。

		 4）在接口中凡是变量必须是public static final，而在抽象类中没有要求。

		 5）抽象类是半抽象的，接口是完全抽象的。

		 6）接口与接口之间支持多继承，抽象类不支持多继承，类和类之间只能单继承；

		 7）一个类可以实现多个接口，但是一个类只能继承一个抽象类

		 8）接口中只允许存在常量和抽象方法；

		 接口的使用要比抽象类的使用更为频繁，接口一般都是对行为的抽象。

		 接口也继承Object类；




	从语法的角度来说，抽象类必须有构造方法，而接口严禁有构造方法，这本身也说明了它们性质的不同。

	抽象类是一个类，别的类是用关键字 extends 来继承下来，并扩展的，有非常强的is-a的关系，这种关系一般来说符合里氏代换原则。

	而接口，是被其他类用关键字 implements 来实现接口定义的方法的。如果没什么区别，何必整出两个不同的关键字。 

	接口只是定义功能和行为规范，如果一个类实现了一个接口，那么这个类必须遵守这个接口的方法约定，但没有is-a的关系。

	把墙壁上的“小学生行为规范”想象成一个接口，那么是小学生必须遵守这个约定，但小学生不是“行为规范”。


构造方法的细节：

		一个类中可以有多个构造方法，多个构造方法是以重载的形式存在的

		构造方法是可以被private修饰的，作用：其他程序无法创建该类的对象。（单例模式）
				


总结一句话：
	
	面向抽象编程，提升程序扩展能力，降低程序耦合度；符合OCP原则

	接口的使用，离不开多态机制，接口+多态	才能达到降低耦合度的目标

	接口可以解耦合，解开的是谁和谁的耦合？
		
		重点： **任何一个接口都有一个调用者和实现者！！！！
		
		解开的是 调用者 和 实现者 之间的耦合；

		调用者面向接口调用

		实现者面向接口编程实现

		后续进行大项目之间的开发，一般都是将项目分离成一个模块一个模块的，模块和模块之间通过接口来实现衔接，降低耦合度。


类型和类型之间的关系：
	
	is a(继承) ; has a（关联） ; like a （实现）;

	is a：
		
		Cat is a Animal(猫是一个动物)
		凡是能满足is a 的表示‘继承关系’
		A extends B;

	has a:
	
		I has a pen(我有一支笔)
		凡是满足has a 关系的表示‘关联关系’；
		关联关系通常以属性的形式存在；
		A {
			B b;
		}
	
	like a:
		
		Cooker like a FoodMenu;(厨师像一个菜单；功能上相似)
		凡是能够满足like a 关系的表示“实现关系”
		实现关系通常是：类实现接口
		A implements B


当自己定义类被定义为属性的时候，和常规的int String等类型的属性所不同的是：

		这些int String属性只能赋值，然后无法再使用；

		而自己定义的类下面的属性虽然也是赋值（堆内存中的内存地址），

		但是还可以使用这个属性下面的方法，属性下还有东西（属性、方法）

		
		