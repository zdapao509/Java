package com.bjpowernode.chapter.array;
/*
选择排序---------每一次选出最小的数放在最左边；循环一次找出参加比较的这堆数据中最小的，拿着个最小的值和最前面的数据做交换

选择排序比冒泡排序的效率更高；高在交换位置的次数上，选择排序的交换位置是有意义的，冒泡里面有很多交换，无意义

算法的思路：
    循环套循环：
        外面的循环代表我每一次最左边从哪里开始，
            比如第一次循环，我从下标为0（第一个数）开始；循环结束之后，我完成了把最小值放在第一个值的位置（也就是下标为0的位置）
            那第二次循环，我第一个值就不用动了，从第二个值开始，找到后面的最小值，然后放在第二个位置，也就是下标为1的位置

        内循环就是负责与上面的外循环开始的那个数进行比较，
            比如，我外循环下标从0开始，那么，内循环就是将0下标之后的所有的数和0下标对应的数比较，找到最小的，然后把这个数赋值给0下标；这就完成一次内循环
            然后，外循环下标变为1，内循环就从下标为2 的地方开始，依次和下标为1的数比较，找到最小值，然后把这个最小值和下标为1的值进行交换，这样就完成了第二次循环

            这里面精妙的点就在于：min指针的出现，永远指向最前面的位置



15,6,8,4,0,41

第一次循环：
    0 6 8 4 15 41
第二次循环：
    0 4 8 6 15 41
第三次循环：
    0 4 6 8 15 41
第四次循环：
    0 4 6 8 15 41
第五次循环：
    0 4 6 8 15 41
* */
public class SeclectSort {
    public static void main(String[] args) {
        int[] arr={15,6,8,4,0,41};
        int count=0;
        int count2=0;
        for (int i = 0; i < arr.length-1; i++) {

            int min=i;//定义最小值的下标。让他在每一次的循环里面都指向本轮循环的数据的最左边；就让他假定起点下标i处对应的数据是最小的

            for (int j = i+1; j < arr.length ; j++) {//本轮循环的数据，min指向的数据和最左边起的第二个数开始进行比较，
                count++;//循环到这里一次，就要进行一次比较
                if (arr[min] >arr[j]) {
                    min=j;//如果最小值发现了更小的值，就交换指针，不交换数据
                }
            }

            if (min != i) {//内部进行比较完之后，如果下标都不一样了，说明这个数已经移位了；最小值的下标不是第一个值了
                /*
                * 当i和min相等时，表示最初的猜测（本轮循环的第一个值是最小值）是对的
                * 当i和min不相等的时候，表示最初的猜测是错的，有比这元素更小的元素
                * 需要拿着这个更小的元素和最左边的元素去交换位置
                *
                * arr[min]表示最小的数据
                * arr[i]表示最前面的数据
                * */
                int temp=arr[i];
                arr[i]=arr[min];
                arr[min]=temp;
                count2++;//执行一次这里，就交换一次
            }
        }
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }
        System.out.println("比较次数："+count);
        System.out.println("交换次数："+count2);
    }
}
