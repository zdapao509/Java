/*
异常的处理机制：

    异常在java中以类的形式存在。那么异常的继承结构是什么样的？

        可用UML图来描述一下继承结构？

            UML是一种建模语言，图标式语言，只要是面向对象的语言，都有UML；

            UML中可以描述类和类之间的继承关系。程序执行的流程，对象的状态等-----------软件工程师必须要能看懂


记住：所有异常都是发生在运行阶段的

    所有的RuntimeException和它的子类都是运行时异常，运行时异常在编写阶段可以选择处理也可以选择不处理

    所有Exception的直接子类都是编译时异常，编译时异常是编译阶段发生的吗？

        不是，编译时异常是表示必须在编写程序的时候预先对这种异常进行处理，如果不处理的话，编译器报错


异常的继承结构：

    Object

    Object下有Throwable---可抛出的

    Throwable下有两个分支，Error(不可处理，直接退出JVM)和Exception（可处理的）

    Exception下有两个分支：

        Exception的直接子类，编译时异常（编译时异常是表示必须在编写程序的时候预先对这种异常进行处理，如果不处理的话，编译器报错）

        RuntimeException：运行时异常，运行时异常在编写阶段，你可以选择处理也可以选择不处理


编译时异常 和 运行时异常 都是发生在 运行阶段，编译阶段异常是不会发生的。

    编译时异常因为什么而得名？

        因为编译时异常必须在编译（编写）阶段预先处理，如果不处理编译器报错，因此得名，所有的异常都发生在运行阶段，

        因为只有在运行阶段，才可以new对象，因为异常的发生就是new异常对象


编译时异常和运行时异常的区别？（编译时异常又被称为受检异常、受控异常CheckedException；运行时异常称为未受检异常、非受控异常 UnCheckedException）

    编译时异常一般发生的概率比较高：对于一些发生概率较高的异常需要在运行阶段对其进行预处理。----------可预见的，所有有必要进行避免

    运行时异常一般发生的概率比较低---------不可避免，没必要进行预处理


假设java中没有分编译时异常和运行时异常，所有的异常都需要在编写程序阶段对其进行预处理：

    这样的操作程序肯定是绝对安全的--------------但是程序员的编写过程比较累



java语言中对异常的处理方式：

    第一种方式：

        在方法声明的位置，使用throws关键字，抛给上一级----------------谁调我，我就抛给谁。

    第二种方式：

        使用try catch 语句进行异常的捕捉

    思考：

        异常发生之后，如果我继续选择了上抛，抛给了我的调用者，调用者需要对这个异常进行处理，它的处理方式还是两个方式，抛给上一级或者try catch捕捉

        注意：java中异常发生之后，如果一直上抛，最终抛给了main方法，main方法继续上抛，抛给了调用者JVM，JVM知道这个异常发生，只有一个结果，终止java程序执行
* */

public class ExceptionTest03 {
    public static void main(String[] args) {
        /*
        程序执行到了此处发生了java.lang.ArithmeticException异常，底层new一个ArithmeticException异常对象，
        然后将异常抛出，由于是main方法调用了100/0，所以这个异常java.lang.ArithmeticException抛给了方法，main方法没有处理，
        将这个异常抛给了JVM，JVM最终终止程序的执行

        java.lang.ArithmeticException继承了RunTimeException，属于运行时异常，在编写程序阶段不需要对异常进行预先的处理
        * */
        System.out.println(100/0);

        System.out.println("----------------");
    }
}
